const axios = require('axios');
const logger = require('./utils/logger');

const NVD_API_BASE = 'https://services.nvd.nist.gov/rest/json/cves/2.0';
const NVD_API_KEY = process.env.NVD_API_KEY;

// Simple in-memory cache (TODO: use Redis for production)
const cveCache = new Map();
const CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours in cache

class CVEChecker {
  async checkVulnerabilities(packages) {
    const vulnerabilities = [];
    
    logger.info(`Checking CVEs for ${packages.length} packages`);
    
    // Process in batches to avoid rate limiting
    const batchSize = 10;
    for (let i = 0; i < packages.length; i += batchSize) {
      const batch = packages.slice(i, i + batchSize);
      
      const batchResults = await Promise.all(
        batch.map(pkg => this.checkPackageVulnerabilities(pkg))
      );
      
      vulnerabilities.push(...batchResults.flat());
      
      // Small delay to be nice to the API
      if (i + batchSize < packages.length) {
        await this.sleep(100);
      }
    }
    
    logger.info(`Found ${vulnerabilities.length} vulnerabilities`);
    return vulnerabilities;
  }
  
  async checkPackageVulnerabilities(pkg) {
    const cacheKey = `${pkg.name}-${pkg.version}`;
    
    // Check cache first
    const cached = cveCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
      return cached.data;
    }
    
    try {
      // In a real implementation, would query NVD API
      // For demo purposes, simulating with mock data
      const vulns = await this.queryNVD(pkg);
      
      cveCache.set(cacheKey, {
        data: vulns,
        timestamp: Date.now()
      });
      
      return vulns;
      
    } catch (err) {
      logger.warn(`CVE check failed for ${pkg.name}: ${err.message}`);
      return [];
    }
  }
  
  async queryNVD(pkg) {
    // TODO: Implement actual NVD API query
    // This is a mock implementation for demonstration
    
    // Simulate API call delay
    await this.sleep(50);
    
    // Mock vulnerability data based on package name heuristics
    const vulns = [];
    
    // Simulate finding vulnerabilities for certain packages
    const riskPackages = ['openssl', 'libssl', 'curl', 'bash', 'openssh'];
    const isRisky = riskPackages.some(name => pkg.name.includes(name));
    
    if (isRisky && Math.random() > 0.3) {
      // Generate mock CVE
      const severity = this.getRandomSeverity();
      vulns.push({
        cveId: `CVE-2024-${Math.floor(Math.random() * 10000)}`,
        package: pkg.name,
        version: pkg.version,
        severity,
        score: this.getCVSSScore(severity),
        description: `Vulnerability found in ${pkg.name} version ${pkg.version}`,
        published: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
        references: []
      });
    }
    
    return vulns;
    
    /*
    // Real NVD API implementation would look like:
    const headers = {};
    if (NVD_API_KEY) {
      headers['apiKey'] = NVD_API_KEY;
    }
    
    const response = await axios.get(NVD_API_BASE, {
      params: {
        cpeName: `cpe:2.3:a:*:${pkg.name}:${pkg.version}:*:*:*:*:*:*:*`
      },
      headers,
      timeout: 10000
    });
    
    return this.parseNVDResponse(response.data);
    */
  }
  
  getRandomSeverity() {
    const rand = Math.random();
    if (rand < 0.1) return 'CRITICAL';
    if (rand < 0.3) return 'HIGH';
    if (rand < 0.6) return 'MEDIUM';
    return 'LOW';
  }
  
  getCVSSScore(severity) {
    const scores = {
      'CRITICAL': 9.0 + Math.random(),
      'HIGH': 7.0 + Math.random() * 2,
      'MEDIUM': 4.0 + Math.random() * 3,
      'LOW': Math.random() * 4
    };
    return Math.min(10, scores[severity]).toFixed(1);
  }
  
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

module.exports = new CVEChecker();
